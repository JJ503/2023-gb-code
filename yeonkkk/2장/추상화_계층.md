# 2장. 추상화 계층
> 코드를 잘 구성한다는 것은 간결한 추상화 계층을 만드는 것으로 귀결될 때가 많다.

## 1. 널값
> 값이 널일 수 있거나 혹은 널이면 안 되는 경우가 항상 명백한 것은 아니라서 문제가 발생한다.
> 널값이 가능한 변수나 반환값을 그에 맞게 표시해야 하고 컴파일러는 반드시 널값 여부 확인을 할 수밖에 없도록 만든다.  
> keyword: 널 안전성(null safety), 보이드 안전성(void safety), 옵셔널(optional)

* 사용 중인 언어가 널 안정성을 지원한다면 사용하는 것이 좋고, 아니라면 `옵셔널(optional)` 타입을 사용하는 것이 좋다.



<br><br>

## 2. 왜 추상화 계층을 만드는가?
> 코드 작성은 복잡한 문제를 계속해서 더 작은 하위 문제로 세분화하는 작업이다.  
> 간결한 추상화 계층은 상위 수준의 문제를 해결하기 위해 몇 가지 개념만 알면 된다는 것을 의미한다.  
> keyword: 추상화 계층(layer of abstraction)


하나의 문제를 하위 문제로 계속해서 나누어 내려가면서 추상화 계층을 만든다면, 같은 층위 내에서는 쉽게 이해할 수 있는 몇개의 개념만 다룬다 → 복잡성 ↓  


<br><br>

### 추상화 계층 및 코드 품질의 핵심 요소
* 가독성
  > 깨끗하고 뚜렷한 추상화 계층을 만드는 것은 개발자가 한 번에 1~2개 정도의 계층과 몇 개의 개념만 다루면 된다는 것을 의미  

* 모듈화
  > 추상화 계층은 하위 문제에 대한 해결책을 깔끔하게 나누고 구현 세부 사항이 외부로 노출되지 않도록 보장한다.  
  > 그렇기 때문에 다른 계층이나 코드의 일부에 영향을 미치지 않고 계층 내에서만 구현을 변경하기가 매우 쉬워진다.  

* 재사용성 및 일반화성
  > 하위 문제에 대한 해결책이 간결한 추상화 계층으로 제시되면 해당 하위 문제에 대한 해결책을 재사용하기가 쉬워지고 일반화될 가능성이 크다.  

* 테스트 용이성
  > 신뢰할 수 있는 코드를 작성하기 위해 각 하위 문제에 대한 해결책이 제대로 작동하는지 확인해야 한다.  

<br><br>

## 3. 코드의 계층
코드를 서로 다른 단위로 분할하여 단위 간의 의존 관계를 보여주는 의존성 그래프를 생성하여 추상화 계층을 생성할 수 있다.  

* 코드를 다른 단위로 나누기 위해 사용하는 요소들: 함수, 클래스, 인터페이스, 패키지, 네임스페이스, 모듈  

<br><br>

### API 및 구현 세부 사항
> 애플리케이션 프로그래밍 인터페이스(application programming interface, API) 는 서비스를 사용할 때 알아야 할 것들에 대한 개념을 형식화하고, 서비스의 모든 구현 세부 사항은 감춘다.  

* API는 호출하는 쪽에 공개할 개념만 정의하면 된다 → 코드를 API의 관점에서 생각하면 추상화 계층을 명확하게 만드는데 도움된다.  

* 코드의 일부를 작성하거나 수정할 때, API에 수정 사항에 대한 구현 세부 정보가 새어 나간다면 추상화 계층이 명확하게 구분된 것이 아니다.  

<br><br>

### 함수
> 어떤 로직을 새로운 함수로 구현하면 유익하다.
> 함수에 포함된 코드가 하나의 짧은 문장처럼 읽히는 것이 이상적이다.  

* 함수를 작성했다면 코드를 문장으로 만들어보자. 
  > 문장 변환이 어렵거나 어색하면 함수가 너무 길다는 것을 의미한다.
  > 더 작은 함수로 나눠보자.  

* 함수를 작게 만들고 수행하는 작업을 명확하게 하면 코드의 가독성과 재사용성이 높아진다.

* 함수를 한 문장으로 표현하기 어렵게 구현했다면 로직의 일부를 헬퍼 함수로 분리하는 것을 고려해봐야한다.  

<br><br>

### 클래스
> 개발자들이 말하는 단일 클래스의 이상적인 크기에 대한 이론과 경험 법칙: 줄 수, 응집력, 관심사 분리
> 응집력과 관심사의 분리에 대해 생각할 때는 서로 관련된 여러 가지 사항을 하나의 사항으로 간주하는 것을 어느 수준에서 해야 유용할지 결정해야 한다.  
> 클래스는 응집력이 있어야 하고 한 가지 일에만 관심을 가져야 한다.  

* 줄 수(number of lines): 한 클래스는 코드 300줄을 넘지 않아야 한다.
  > 300줄보다 긴 클래스는 너무 많은 개념을 다루므로 분리해야 한다.
  > 하지만 300줄 이하의 클래스는 무조건 적절한 크기임을 뜻하지는 않는다.  

* 응집력(cohesion): 한 클래스 내의 모든 요소들이 얼마나 잘 속해있는지 보여주는 척도
  > 좋은 클래스는 응집력이 강하다.
  > * 순차적 응집력, 기능적 응집력이 있다. 

* 관심사의 분리(separation of concerns): 시스템이 각각 별개의 문제나 관심사를 다루는 개별 구성 요소로 분리되어야 한다고 주장하는 설계 원칙이다.

<br>

개발자는 1. 단일 클래스 내에 얼마나 많은 다른 개념이 들어가 있는지 2. 어떤 로직이 재사용이나 재구성에 적합한지에 대해 신중하게 생각해야 한다.  
기존 코드를 수정할 때나 완전히 새로운 코드를 작성할 때 클래스가 너무 커지는 것은 아닌지 주의해야 한다.  
코드를 적절한 크기의 클래스로 쪼개지 않으면 너무 많은 개념을 한꺼번에 다루고, 가독성이 떨어지며 모듈화가 덜 이루어지고, 재사용과 일반화가 어렵고, 테스트하기도 어려워진다.  

클래스가 분리되어야 할지 판단하기 위해서는 4가지 핵심 요소에 반하여 작성되어 있는지 살펴봐야한다.  
* 코드를 읽을 수 없다.  
* 코드가 특별히 모듈화되어 있지 않다.  
* 코드를 재사용할 수 없다.  
* 코들르 일반화할 수 없다.  
* 코드를 제대로 테스트하기 어렵다.  

코드를 적절한 크기의 클래스로 세분화하는 것은 추상화 계층을 잘 만들기 위한 가장 효과적인 도구이기 때문에 이를 위한 시간과 노력을 들일 만한 가치가 충분히 있다.  

<br><br>

### 인터페이스  
> 계층 사이를 뚜렷하게 구분하고 구현 세부 사항이 계층 사이에 유출되지 않도록 하기 위해 사용할 수 있는 한 가지 접근법은 어떤 함수를 외부로 노출할 것인지를 인터페이스를 통해 결정하는 것이다.  





