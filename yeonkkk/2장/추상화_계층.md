# 2장. 추상화 계층
> 코드를 잘 구성한다는 것은 간결한 추상화 계층을 만드는 것으로 귀결될 때가 많다.

<br><br>

## 요약
* 코드를 깨끗하고 뚜렷한 추상화 계층으로 세분화하면 **가독성, 모듈화, 재사용, 일반화 및 테스트 용이성이 향상**된다.
* 특정 언어에 국한된 기능뿐만 아니라 **함수, 클래스 및 인터페이스**를 사용하여 코드를 추상화 계층으로 나눌 수 있다.  
* 코드를 추상화 계층으로 분류하는 방법을 결정하려면 해결 중인 문제에 대한 판단과 지식을 사용해야 한다.
* 너무 비대한 계층 때문에 발생하는 문제는 너무 얇은 계층 때문에 발생하는 문제보다 더 심각하다.   
  **확실하지 않은 경우에는 남용의 위험에도 불구하고 계층을 얇게 만드는 것이 좋다.**  

<br><br>

## 1. 널값
> 값이 널일 수 있거나 혹은 널이면 안 되는 경우가 항상 명백한 것은 아니라서 문제가 발생한다.
> 널값이 가능한 변수나 반환값을 그에 맞게 표시해야 하고 컴파일러는 반드시 널값 여부 확인을 할 수밖에 없도록 만든다.  

* 사용 중인 언어가 널 안정성을 지원한다면 사용하는 것이 좋고, 아니라면 `옵셔널(optional)` 타입을 사용하는 것이 좋다.



<br><br>

## 2. 왜 추상화 계층을 만드는가?
> 코드 작성은 복잡한 문제를 계속해서 더 작은 하위 문제로 세분화하는 작업이다.  
> 간결한 추상화 계층은 **상위 수준의 문제를 해결하기 위해 몇 가지 개념만 알면 된다는 것을 의미**한다.  


하나의 문제를 하위 문제로 계속해서 나누어 내려가면서 추상화 계층을 만든다면, 같은 층위 내에서는 쉽게 이해할 수 있는 몇개의 개념만 다룬다 → 복잡성 ↓  


<br><br>

### 추상화 계층 및 코드 품질의 핵심 요소

* **가독성**
  > 깨끗하고 뚜렷한 추상화 계층을 만드는 것은 개발자가 한 번에 1~2개 정도의 계층과 몇 개의 개념만 다루면 된다는 것을 의미  

* **모듈화**
  > 추상화 계층은 하위 문제에 대한 해결책을 깔끔하게 나누고 구현 세부 사항이 외부로 노출되지 않도록 보장한다.    
  > 그렇기 때문에 다른 계층이나 코드의 일부에 영향을 미치지 않고 계층 내에서만 구현을 변경하기가 매우 쉬워진다.  

* **재사용성 및 일반화성**
  > 하위 문제에 대한 해결책이 간결한 추상화 계층으로 제시되면 해당 하위 문제에 대한 해결책을 재사용하기가 쉬워지고 일반화될 가능성이 크다.  

* **테스트 용이성**
  > 신뢰할 수 있는 코드를 작성하기 위해 각 하위 문제에 대한 해결책이 제대로 작동하는지 확인해야 한다.  

<br><br>

## 3. 코드의 계층
코드를 서로 다른 단위로 분할하여 단위 간의 의존 관계를 보여주는 **의존성 그래프**를 생성하여 추상화 계층을 생성할 수 있다.  

* 코드를 다른 단위로 나누기 위해 사용하는 요소들: 함수, 클래스, 인터페이스, 패키지, 네임스페이스, 모듈  

<br><br>

### API 및 구현 세부 사항
> 애플리케이션 프로그래밍 인터페이스(application programming interface, API)는 서비스를 사용할 때 알아야 할 것들에 대한 개념을 형식화하고, 서비스의 모든 구현 세부 사항은 감춘다.  

* API는 호출하는 쪽에 공개할 개념만 정의하면 된다 → 코드를 API의 관점에서 생각하면 추상화 계층을 명확하게 만드는데 도움된다.  

* 코드의 일부를 작성하거나 수정할 때, API에 수정 사항에 대한 구현 세부 정보가 새어 나간다면 추상화 계층이 명확하게 구분된 것이 아니다.  

<br><br>

### 함수
> 어떤 로직을 새로운 함수로 구현하면 유익하다.  
> 함수에 포함된 코드가 **하나의 짧은 문장**처럼 읽히는 것이 이상적이다.  

* 함수를 작성했다면 코드를 문장으로 만들어보자. 
  > 문장 변환이 어렵거나 어색하면 함수가 너무 길다는 것을 의미한다.  
  > 더 작은 함수로 나눠보자.  

* 함수를 작게 만들고 수행하는 작업을 명확하게 하면 코드의 가독성과 재사용성이 높아진다.

* 함수를 한 문장으로 표현하기 어렵게 구현했다면 로직의 일부를 헬퍼 함수로 분리하는 것을 고려해봐야한다.  

<br><br>

### 클래스
> 개발자들이 말하는 단일 클래스의 이상적인 크기에 대한 이론과 경험 법칙: 줄 수, 응집력, 관심사 분리
> 응집력과 관심사의 분리에 대해 생각할 때는 서로 관련된 여러 가지 사항을 하나의 사항으로 간주하는 것을 어느 수준에서 해야 유용할지 결정해야 한다.  
> 클래스는 응집력이 있어야 하고 한 가지 일에만 관심을 가져야 한다.  

* **줄 수(number of lines)**: 한 클래스는 코드 300줄을 넘지 않아야 한다.
  > 300줄보다 긴 클래스는 너무 많은 개념을 다루므로 분리해야 한다.   
  > 하지만 300줄 이하의 클래스는 무조건 적절한 크기임을 뜻하지는 않는다.  

* **응집력(cohesion)**: 한 클래스 내의 모든 요소들이 얼마나 잘 속해있는지 보여주는 척도
  > 좋은 클래스는 응집력이 강하다.   
  > 순차적 응집력, 기능적 응집력이 있다. 

* **관심사의 분리(separation of concerns)**: 시스템이 각각 별개의 문제나 관심사를 다루는 개별 구성 요소로 분리되어야 한다고 주장하는 설계 원칙이다.

<br><br>

개발자는 **1. 단일 클래스 내에 얼마나 많은 다른 개념이 들어가 있는지 2. 어떤 로직이 재사용이나 재구성에 적합한지**에 대해 신중하게 생각해야 한다.  
기존 코드를 수정할 때나 완전히 새로운 코드를 작성할 때 클래스가 너무 커지는 것은 아닌지 주의해야 한다.  

<br>

클래스가 분리되어야 할지 판단하기 위해서는 **4가지 핵심 요소**에 반하여 작성되어 있는지 살펴봐야한다.  
* 코드를 읽을 수 없다.  
* 코드가 특별히 모듈화되어 있지 않다.  
* 코드를 재사용할 수 없다.  
* 코드를 일반화할 수 없다.  
* 코드를 제대로 테스트하기 어렵다.  

<br>

코드를 적절한 크기의 클래스로 세분화하는 것은 추상화 계층을 잘 만들기 위한 가장 효과적인 도구이기 때문에 이를 위한 시간과 노력을 들일 만한 가치가 충분히 있다.  

<br><br>

### 인터페이스  
> 계층 사이를 뚜렷하게 구분하고 구현 세부 사항이 계층 사이에 유출되지 않도록 하기 위해 사용할 수 있는 한 가지 접근법은 어떤 함수를 외부로 노출할 것인지를 인터페이스를 통해 결정하는 것이다.  
> 하나의 추상화 계층에 대해 두 가지 이상의 다른 방식으로 구현을 하거나 향후 다르게 구현할 것으로 예상되는 경우 인터페이스를 정의하는 것이 좋다.  

인터페이스를 정의하지 않더라도 클래스에서 어떤 함수를 퍼블릭으로 노출할지 신중하게 생각해야 하며, 구현 세부 사항이 유출되지 않도록 해야 한다.  

<br><br>

#### Q. 주어진 추상화 계층에 대해 한 가지 구현만 있고 향후에 다른 구현을 추가할 계획이 없더라도 인터페이스를 통해 추상화 계층을 표현해야 하는가?
> 팀 내에서 결정할 사안이다.   
> 일부 소프트웨어 공학 철학은 이러한 경우에도 인터페이스를 사용할 것을 권고한다.  

* 위 접근 방식의 **장점**
  * 퍼블릭 API를 정확하게 보여준다.
  * 한 가지 구현만 필요하다고 잘못 추측한 것일 수 있다.
  * 테스트를 쉽게 할 수 있다.
  * 같은 클래스로 두 가지 하위 문제를 해결할 수 있다.

* 위 접근 방식의 **단점**
  * 더 많은 작업이 필요하다.
  * 코드가 복잡해질 수 있다.


<br><br>

### 얇아진 층
> 코드를 계층별로 세분화하면 추가 비용이 발생한다.  
> 분할을 위한 분할은 의미가 없다는 것을 명심하자.  

* 발생하는 추가 비용
  * 클래스 정의, 의존성을 새 파일로 임포트하려고 사용하는 코드로 인한 코드 양 증가
  * 로직 이해를 위한 노력 (클래스, 파일을 따라가야 한다)
  * 로직을 이해하거나 디버깅하는 것이 더 어려워질 수 있음

<br><br>


**코드 계층의 규모**를 결정하는 것은 중요하다.  

계층이 너무 크면 모듈화되지 않고, 재사용이 불가하며, 가독성이 낮아진다.  
계층이 너무 얇으면 불필요한 복잡성을 초래한다.  

어떤 것이 더 나을지 불확실하다면, 계층을 여러 개로 나누는 것이 한 계층 안에 모든 코드를 집어넣는 것보다는 낫다.  

계층을 몇 개로 나눌지는 **가독성, 재사용성, 일반화성, 모듈화 가능성, 테스트 용이성을 고려**해서 판단하자.  

<br><br>

## 4. 마이크로서비스
마이크로서비스 아키텍처에서는 개별 문제에 대한 해결책이 독립적으로 실행되는 서비스로 배포된다.  
시스템이 여러 개의 소규모 프로그램으로 분할되어 특정 작업만 전문적으로 수행하는 것이다.  
대개 크기와 범위를 기준으로 마이크로서비스를 나누기 때문에 여전히 그 내부에서 적절한 추상화 계층을 고려하는 것이 유용하다.  








