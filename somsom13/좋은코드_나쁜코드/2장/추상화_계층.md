# 2장 추상화 계층

----

**코드를 잘 구성한다 == 간결한 추상화 계층을 만든다**

## 1. null 값 및 의사 코드 규약

**null** : 값이 없다
- 함수가 특정 요청에 대해 값을 반환할 수 없을 때, null 을 반환하도록 하는 경우가 다수
  - null 체크가 사전에 이루어지지 않으면 예외가 발생할 수 있다.
- null 안전성을 지원하는 언어의 활용
```java
// null 안전성 보장 예시
Element? getFirstElement() { // 반환 타입 뒤에 ? 가 붙는다 => 반환값이 null 일 수 있음을 명시
        if (this.elements.isEmpty()) {
        return null; // 반환값이 null 일 수 있음
        }
        return this.elements.get(0);
        }
```


```java
// Optional 사용 예시 (null 안전성이 보장되지 않는 경우)
Optional<Element> getFirstElement() { // 반환 타입: Optional Element
	if (this.elements.isEmpty()) {
		return Optional.empty(); // null 대신 Optional.empty 를 반환한다
	}
	return this.elements.get(0); // 있다면 해당 값이 반환된다
}
```



## 2. 왜 추상화 계층을 만드는가
**코드 작성은 복잡한 문제를 하위의 작은 문제로 세분화 하는 것이다.**

> HttpConnection 으로 서버에게 메세지를 보내는 코드를 작성할 때, 우리는 **이미 정의되어 있는 API를 활용** 하여 복잡한 내부 로직을 몰라도, 쉽게 코드를 작성할 수 있다.
> <br> 여기서 **이미 정의되어 있는 API란, 다른 개발자들이 하위 문제에 대해 작성해둔 해결책** 을 의미한다.

- 추상화 계층의 장점: 위의 예시에서 우리는 메세지를 보내기 위해 'HTTP 연결이 필요하다!' 라는 추상적인 개념만 알아도 이미 있는 API를 활용해 간단하게 문제를 해결할 수 있다.
  - **하나의 문제를 하위 문제로 나누어 내려가면서 추상화 계층을 만들 수 있다. &rightarrow; 해당 층위에서는 하위의 문제를 고려하지 않고, 몇 개의 추상적인 개념만 알면 되기 때문에
  개별 코드는 복잡해 보이지 않는다.**

    
- **뚜렷한 추상화 계층으로 달성할 수 있는 고품질 코드 요구사항 4가지**
  - 가독성
    - 코드의 세부 사항을 모두 알지 못해도, 계층의 추상화를 이해하고 활용할 수 있다. &rightarrow; 코드의 가독성 향상
  - 모듈화
    - 추상화 계층이 구현 세부를 외부로 노출시키지 않으며, 자신의 하위 문제를 깔끔하게 나누게 되면 **계층 내의 변경 사항이 외부에 영향을 미치지 않게 된다**
    - 현재 계층에서는 하위 계층의 문제에 신경쓰지 않아도 된다.
  - 재사용성 및 일반화성
    - 하위 문제에 대해 이미 정의된 해결책 재사용 가능
    - 하나의 해결책이 유사 상황에서 일반화 될 가능성 있음
  - 테스트 용이성
    - 하위 문제에 대한 해결책을 완벽하게 테스트, 검증하기 쉬워진다.


## 3. 코드의 계층
> 추상화 계층 생성 방법: 코드를 분할 &rightarrow; **단위 별로 의존성 그래프**를 그리는 것

- 단위
  - 함수
  - 클래스
  - 인터페이스
  - 패키지, 네임스페이스, 모듈

---
### 퍼블릭 API와 세부 사항
- API: _어플리케이션 프로그래밍 인터페이스_
  - 서비스를 사용할 때, 알아야 할 개념을 형식화 하고 구현 세부 사항은 숨긴다.
- 공개 API: 호출하는 쪽에서 알 수 있는 사항
  - EX) 퍼블릭 함수명, 필요한 파라미터 및 반환 타입, 클래스 명
- 비공개 요소: 세부 구현 사항, 프라이빗 메서드, 인스턴스 변수
> 코드를 API 관점에서 생각하면 추상화 계층을 명확히 이해하는데 도움이 된다.

---


### 메서드 (함수)
하나의 메서드가 하는 일을 문장으로 표현했을 때, 하나의 잘 써진 짧은 문장으로 읽힌다면 분리가 잘 이루어진 것이다.

> EX) 
> <br> 집 주소를 찾고 그 집 주소의 주인에게 메일을 보낸다 : 너무 긴 문장
> <br> 집 주소를 찾는다. 주소가 있다면 메일을 보낸다. : 일을 여러개로 분리하여, 한 눈에 읽힌다

- 한 메서드는 하나의 일만 수행한다.
- 복잡한 일을 해야하는 경우, 다른 메서드를 호출하여 수행하도록 한다.

> 메서드를 문장으로 만들기 어렵거나, 문장이 어색하다면 메서드가 너무 길다는 의미이다. 더 작은 메서드로 나누어보자

- 메서드를 잘 분리했을 때의 장점
  - 코드 가독성 향상
  - 추후 재사용 가능성 향상

---

### 클래스
- 클래스와 관련된 이론, 경험 법칙
    - 줄 수: 한 클래스 내의 코드 라인이 너무 길어지면 너무 많은 개념을 다룬다는 것
    - 응집력: 한 클래스 내의 모든 요소들이 얼마나 잘 속해있는가 → 좋은 클래스는 응집력이 높다.
        - 순차적 응집력: 한 요소의 출력이 다른 요소의 입력으로 들어가는 경우<br>
          ex) 원두를 간다 → 갈린 원두가 커피 추출에 쓰인다 ⇒ 갈기와 추출 사이에는 응집력이 있다
        - 기능적 응집력: 몇 가지 요소들이 모여서 하나의 일을 성취하는데 기여하는 경우<br>
          ex) 케이크를 만들 때 필요한 장비 (그릇, 숟가락, 케이크 통 등) 을 하나의 선반에 모아서 보관하는 것
    - 관심사의 분리: 시스템을 각각 별개의 문제를 다루는 개별 요소로 분리하는 것
      ex) 게임 실행과 연관된 게임 콘솔 / TV 는 하나로 합쳐져 있지 않은 별개의 요소이다.


- **클래스가 고품질 코드를 위한 요구사항 4가지에 미치는 영향**

  - 코드 가독성
      - 단일 클래스가 가지는 개념이 많을 수록 해당 클래스의 가독성이 떨어진다
  - 코드 모듈화
      - 하위 문제의 해결책: 하나의 관심사 이므로 별개의 클래스로 구현한다.
      - 이를 상위 클래스에서 활용할 때 퍼블릭 API 로만 접근할 수 있다면(즉 세부 사항은 모르는 것), 상위 문제에서 써야 하는 하위 문제의 해결책 (정책) 이 변경되었을 때 이를 쉽게 교체할 수 있다.
  - 코드 재사용성 및 일반화 → 하나의 단일 클래스가 자신의 하위 문제 여러개를 private 메서드로 가지고 있는 경우
      - 두 개의 하위 문제가 있다고 했을 때, 하나의 해결책이 이미 구현이 되어있고 / 다른 하나의 하위 문제를 새롭게 구현해야 할 때, 두 하위 해결책이 private 이면 해당 해결책을 다른 곳에서 재사용 할 수 없어진다.
  - 테스트 용이성
      - 클래스가 잘 분리될 수록, 각 로직을 적절하게 테스트 하기 쉬워진다

> 클래스 분리 여부를 판단하기 위해서는 해당 클래스가 고품질 코드 요구사항에 어떻게 위배되는지를 생각해보자

**하위 문제를 테스트 해야 하거나, 재사용 해야 할 때 하위 문제를 클래스로 분리하는 것이 고품질 코드의 요구사항에 도움이 된다.**
- 상위 문제에서 하위 문제에 대한 해결책을 어떻게 활용하는가?
  - 생성자로 하위 문제 해결책을 주입받는다. &rightarrow; **의존성 주입**

---

### 인터페이스
인터페이스를 통해 계층 사이를 구분하고, 구현 세부 사항이 계층 사이에 노출되지 않게 할 수 있다. <br>
**인터페이스를 통해 외부로 노출할 함수를 결정할 수 있다!**

- 인터페이스 사용의 장점
  - 하나의 추상화 계층에 대해 구현을 다르게 할 가능성이 생기는 겨우, 구현체를 갈아끼울 수 있다.
  - 다양한 구현이 가능하다.
  - 코드의 모듈화가 잘 이루어진다.

- 구현체가 한 가지여도 인터페이스를 정의할 경우의 장점
  - 퍼블릭 API가 명시적으로 보여진다.
    - 인터페이스에 명시된 메서드만 사용 가능함이 명확히 드러난다.
  - 추후 새로운 구현이 필요해졌을 때, 쉽게 구현체를 추가 및 교체할 수 있다. (추후 가능성을 고려)
  - 테스트가 간단해진다. 
    - 테스트를 위한 mock 이나 페이크 객체를 생성할 수 있다.
  - 코드의 일반화 가능성을 높일 수 있다. 
    - 하나의 클래스로 두 가지 문제를 해결할 수 있다. 
- 단점
  - 인터페이스 정의로 작성할 코드의 양이 증가한다.
  - 타 개발자가 세부 동작 방식을 알고 싶을 때, 인터페이스 &rightarrow; 클래스로 이동해야 한다는 번거로움이 생긴다.

> 인터페이스를 사용했을 때의 장점이 확실한 경우에만 활용하자


## 4. 마이크로 서비스
> 마이크로서비스 아키텍처: 단일 문제에 대한 해결 방안을 클래스를 넘어서, 하나의 별도의 독립적인 서비스로 배포한다.

마이크로서비스를 사용해도 하나의 서비스 내에서 해결해야 할 여러 하위 문제가 발생하기 때문에 여전히 추상화 계층의 분리가 필요하다.